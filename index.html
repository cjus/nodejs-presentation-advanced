<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>An Introduction to NodeJS</title>
  <meta name="description" content="NodeJS Advanced Presentation">
  <meta name="author" content="Carlos Justiniano">
  <meta name="apple-mobile-web-app-capable" content="yes"/>
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

  <link rel="stylesheet" href="css/reveal.min.css">
  <link rel="stylesheet" href="css/theme/night.css" id="theme">
  <link rel="stylesheet" href="css/presentation.css">

  <!-- For syntax highlighting -->
  <link rel="stylesheet" href="lib/css/zenburn.css">

  <!-- If the query includes 'print-pdf', include the PDF print sheet -->
  <script>
    if (window.location.search.match(/print-pdf/gi)) {
      var link = document.createElement('link');
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = 'css/print/pdf.css';
      document.getElementsByTagName('head')[0].appendChild(link);
    }
  </script>

  <!--[if lt IE 9]>
  <script src="lib/js/html5shiv.js"></script>
  <![endif]-->
</head>
<body>

<div class="reveal">
<div class="slides">

<!-- To print: http://localhost:8000/?print-pdf/#/ -->


<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Title slide  ----------------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="cube" data-transition-speed="medium">
  <img style="border: 0; padding: 0; width: 25%;" src="images/nodejs-sticker-advanced.png">

  <h2>An Advanced Introduction<br>to NodeJS</h2>
  <p>
    <small>Presented by <a href="http://cjus.me" target="_blank">Carlos Justiniano</a> /
      <a href="http://www.meetup.com/Hudson-County-JavaScript-Meetup/" target="_blank">HC.JS</a> /
      <a href="http://twitter.com/cjus" target="_blank">@cjus</a> / ver: 1.0.0</small>
  </p>
  <aside class="notes" data-markdown="">
    ---
  </aside>
</section>


<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- About me  -------------------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>About me</h3>
  <ul>
    <li>Carlos Justiniano, HC.JS founder and a long-time programmer</li>
    <li>A fullstack developer using NodeJS since 2011</li>
    <li>Developed Node applications in production use</li>
    <li>Developer at MediaMath, note: we're hiring!</li>
  </ul>

  <aside class="notes" data-markdown="">
    ---
  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Node = NodeJS ---------------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="slow">
  <h2>Node = NodeJS</h2>
  <aside class="notes" data-markdown="">
    ---
    In this presentation I'll refer to NodeJS simply as Node.
  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- This is part two ------------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="slow">
  <h3>This is part two</h3>
  <ul>
    <li>Part one is here: http://cjus.github.io/nodejs-presentation</li>
  </ul>
  <aside class="notes" data-markdown="">
    ---
    In our last presentation we looked at NodeJS as a JavaScript execution engine and platform for building everything
    from command line tools and desktop applications - to full-blown web applications.

    In addition we looked at installing Node and adding packages such as the Express web application framework.

    If you missed that talk you can find it here… http://cjus.github.io/nodejs-presentation
  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Quick recap ------------------------------------------------------------------------------------------------------>
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Quick recap</h3>
  <ul>
    <li>Node is an application which contains a JavaScript execution engine</li>
    <li>Specifically, that engine is Google's Chrome V8 engine</li>
    <li>However, Node is also much more</li>
  </ul>
  <aside class="notes" data-markdown="">
    ---
    Let’s do a quick recap before diving into more advanced Node topics.

    So we discussed node as a JavaScript execution engine because node is an application - which contains an embedded
    JavaScript interpreter for running JavaScript programs.

    Node is actually much more, but this simple definition serves as a foundation for learning more about Node.
  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Quick recap - Node as a JS execution engine ---------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Node as a JS execution engine</h3>
  <ul>
    <li>Start node at the terminal</li>
    <li>Node then enters a mode called a REPL (Read Eval Print Loop)</li>
    <li>Type JS and watch it execute</li>
    <li>Tip: Press the TAB key to view a list of internal commands</li>
    <li>Press CTRL-C twice to exit</li>
  </ul>
  <aside class="notes" data-markdown="">
    ---
    Let’s see how Node works as a JavaScript execution engine.

    Here’s a quick demo. Let’s start Node at the terminal prompt. We won’t go into installing node, that’s covered in
    the last presentation.

    $ node

    That starts the Node and enters an interactive mode known as a REPL which is an acronym for Read Eval(uate) Print
    Loop. We can enter JavaScript in this console and see the results.

    Tip: Press the TAB key to view a list of internal commands

    To exit simply press CTRL-C twice.
  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Quick recap - Node as a tool to build command line programs ------------------------------------------------------>
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Node as a tool to build command line programs</h3>
  <ul>
    <li>Code sample here: https://github.com/cjus/nodejs-presentation-advanced/tree/master/NodeJSProjects/commandline</li>
  </ul>
  <aside class="notes" data-markdown="">
    ---
    Node can also be used to build programs that execute on the command line.
    Here’s our example of a command line program which displays system information.
  </aside>
</section>


<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Quick recap - Node as a web server ------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Node as a web server</h3>
  <ul>
    <li>Code sample here: https://github.com/cjus/nodejs-presentation-advanced/tree/master/NodeJSProjects/web/login</li>
  </ul>
  <aside class="notes" data-markdown="">
    ---
    We also saw how Node can be used to serve web pages and even act as an API server as part of a larger web
    applications.

    Here’s that demo.
  </aside>
</section>


<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Quick recap - Node as an API server ------------------------------------------------------------------------------>
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Node as an API server</h3>
  <img style="border: 0; padding: 5px;" src="images/login-using-paw.png">
  <aside class="notes" data-markdown="">
    ---
    In the last demo Node is functioning as both a web server and an API server. To demonstrate this, let’s login using
    a desktop client called PAW. PAW is a mac only tool for testing APIs that is popular among API developers.

    Using PAW we can see how our API request is constructed and what Node returns in response.

    We can also see this on the command line as the calls happen.

    We’ll get back to this example a bit later, for now let’s take a slight detour and learn about web frameworks for
    Node.
  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Node web frameworks ---------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Node web frameworks</h3>
  <ul>
    <li>The last demo used a web framework, an add-on which consists of code that simplifies the creation of web
      applications</li>
    <li>There are lots of frameworks to choose from: ExpressJS, HapiJS, Koa and KrakenJS to name a few.</li>
    <li>These frameworks differ in how they're configured, create servers, handle routing and middleware</li>
  </ul>
  <aside class="notes" data-markdown="">
    ---
    The last demo shows Node as an API server. To accomplish we made use of a node package called a web framework.

    A web framework consist of code which simplifies the creation of web applications. In this regard, there are a
    number of frameworks available for Node. Which framework you should use depends on your projects needs.

    The most popular are Express.js, Hapi.js and Koa.js, KrakenJS

    These frameworks differ in how they create servers, handle routing and middleware. These are topics we haven’t
    addressed in this presentation but you can learn more about them online.
  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Framework popularity --------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Framework popularity</h3>
  <h4>The following data is from an article entitled<br>"Node.js Framework Comparison: Express vs. Koa vs. Hapi"</h4>

  https://www.airpair.com/node.js/posts/nodejs-framework-comparison-express-koa-hapi
  <aside class="notes" data-markdown="">
    ---
    The following data is from an article entitled "Node.js Framework Comparison: Express vs. Koa vs. Hapi"
    https://www.airpair.com/node.js/posts/nodejs-framework-comparison-express-koa-hapi
  </aside>
</section>


<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- ExpressJS is most popular ---------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Framework popularity</h3>
  <img style="border: 0; padding: 5px;" src="images/framework_table_01.png">
  <aside class="notes" data-markdown="">
    ---
    The data shows that the Express.js framework is by far the most popular based on a number of important metrics.

    | Metric | Express.js | Koa.js | Hapi.js
    | —————— | ——————: | ——: | ——:
    | Github Stars | 16,158 | 4,846 | 3,283
    | Contributors | 163 | 49 | 95
    | Packages that depend on: | 3,828 | 99 | 102
    | StackOverflow Questions | 11,419 | 72 | 82
  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Available books -------------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Available books</h3>
  <img style="border: 0; padding: 5px;" src="images/framework_table_03.png">
  <aside class="notes" data-markdown="">
    ---
    Another important metric is how many books and online tutorials you can find while trying to learn a framework.

    I did a quick search on Google Shopping for books on Express, Koa and Hapi:

    |Framework | Query | Hits
    |—————— | :——: ——:
    | Express.js | “express.js” +book | dozens
    | Hapi.js | “hapi.js” +book | 1
    | Koa.js | “koa.js” +book | 0
    | Kraken.js | “kraken.js” +book | 0
  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Framework age ---------------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Framework age</h3>
  <img style="border: 0; padding: 5px;" src="images/framework_table_02.png">
  <aside class="notes" data-markdown="">
    ---
    That said, Express.js is also the oldest Node framework. So it’s conceivable that another framework may someday
    exceed it in popularity among developers.

    For now at least, Express would be a reasonable place to start.

    | Framework | First version
    |—————— | ——:
    | Express.js | June 2009
    | Hapi.js | August 2011
    | Koa.js | August 2013

    In our earlier talk we looked at the ExpressJS framework for Node. That’s the framework behind our prior demo.
  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Code review of a Node / Express app  ----------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Code review of a Node / Express app</h3>
  <ul>
    <li>Code can be found in this presentation's repo on GitHub: https://github.com/cjus/nodejs-presentation-advanced</li>
    <li>Look inside of the NodeJSProjects/web/login folder</li>
  </ul>
  <img style="border: 0; padding: 5px; width: 30%" src="images/login-app-file-structure.png">
  <aside class="notes" data-markdown="">
    ---
    Let’s revisit our login sample application. We’ll take a closer look at how the application is constructed. Our
    example uses the Express framework, but keep in mind that what you’ll see is comparable to what you’ll find in other
    frameworks.

    The source for our application can be found this presentation’s repo on GitHub:
    https://github.com/cjus/nodejs-presentation-advanced

    You’ll find the login application in the NodeJSProjects/web/login folder.

    Our application’s JavaScript can be found in the project’s root, app.js and in the routes and bin folder. The
    node_modules folder is where our package dependencies are stored. We’ll learn more about node packages shortly. The
    views folder contains web templates which are not really used in this project.

    The routes folder contains handlers for the URLs our application handles. More about that shortly.

    The public folder holds are website files, which Node will statically serve when users access our site.

    Let’s see how this all comes together.
  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Application Routes  ---------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Application Routes</h3>
  <ul>
    <li>Site loads from: http://localhost:3000</li>
    <li>Site calls http://localhost:3000/api/v1/login from the login page</li>
  </ul>
  <aside class="notes" data-markdown="">
    ---
    At a high level when the user visits our site, in our case at http://localhost:3000, our Express based app will
    handle that URL and respond by sending back the sites index.html from the public folder. That will then trigger the
    user’s web browser to make requests for the associated javascript and CSS files.

    Once our site loads in the user’s browser they’re able to login to our application by sending their user name and
    password. That is essentially a jQuery AJAX call to http://localhost:3000/api/v1/login

    So in this basic example, our application is both serving a website and responding to an API request.

    Note the format of our API URL. It contains a path to ‘api’ followed by a ‘v1’ segment and a ‘login’ segment. This
    structuring allows us to differentiate API requests from other requests, such as loading the site’s CSS.
    Additionally the v1 portion allows us to support multiple API versions. The last portion is the login which is the
    name of the individual API. We might, for example, have a logout API.
  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Login Route  ----------------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium" data-markdown="markdown/login.md"
         data-separator="^\n\n\n" data-separator-vertical="^\n\n">
  <aside class="notes" data-markdown="">
    ---
    Let’s look at some code.

    The first thing we do to wire up our login handler is to add a route entry to our app.js file. Here we’re just
    saying that when express see’s a request for /api/v1/login it should send that request to our login.js handler.

    The separates a login path from the code which actually handles it.

    At the very top of our login.js handler we see a warning about this code fragment not being secure. Don’t do this at
    work!

    We create an express object which uses the requires function to load the express module. We then create a router
    object from express.Router.

    We’ll look at node modules a bit later in this presentation.

    So we essentially provide an anonymous function as our route handler. Note the function signature contains three
    parameters: req, res, next. The request object allows us to see the contents of a request. This allows us to examine
    HTTP headers and review body responses such as a JSON object that might have been sent from our website. The
    response object allows us to package up a response which will then get sent back to the user’s web browser or
    calling client, such as PAW.

    The last parameter, next, is used to chain request processing - but we won’t go into that in this presentation.

  </aside>
</section>


<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Client requests  ------------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium" data-markdown="markdown/loginrequest.md"
         data-separator="^\n\n\n" data-separator-vertical="^\n\n">
  <aside class="notes" data-markdown="">
    ---
    In public/javascripts/app.js we see our API request which will get sent to api/v1/login. This uses the $.post jQuery
    method to send a JSON object to our server.

    Note who the request object has handlers for done and fail. Because our response won’t be handled immediately we
    have to create callback handler for use when a response arrives. This pattern is known as promises and it’s
    something you should be using in your own applications. In this case we’re using jQuery promises and you can learn
    more about them online.

    Another point worth noting is that our request is to ‘api/v1/login’ because the API handling is on the same server
    as the one where the website is being served from. You could make requests to other servers by using something like
    ‘http://someserver.com/api/v1/login'. This also allows you to have one node server to serve web content and another
    to process API requests. This core concept will later lead us to micro services the new web hotness.

    So in addition to handling requests, Node applications can also make requests in the same manner listed in this
    example. This allows Node applications to communicate with one another and to become larger than the sum of their
    parts.
  </aside>
</section>


<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Using modules in Node  ------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Using modules in our app</h3>
  <ul>
    <li>npm install module_name</li>
    <li>for example: npm install express</li>
    <li>Then require('module_name') in our app</li>
  </ul>
  <aside class="notes" data-markdown="">
    ---
    In the last example we saw how our login handler requested the express module and called the Router constructor to
    create a new route.

    That allows us to build on an existing express component. In a similar fashion you might need to create an Excel
    spreadsheet or access a remote database. Node handles this by allowing you to load modules which address your
    particular need.

    In the first presentation we saw how we could add a module, such as express.

    Then we can require the module for use in our app.

  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- NPM - The Node Package Manager  ---------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>NPM - The Node Package Manager</h3>
  <ul>
    <li>The Node Package Manager is a tool which ships with Node and assist with the searching, packaging, publishing
      and updating of node modules</li>
  </ul>
  <aside class="notes" data-markdown="">
    ---
    Modules offer a huge boon to developers building Node-based applications. By building modules you’re able to package
    reusable functionality to share across projects within your company or with the global open source community at
    large. And better yet you can locate modules which perhaps address your project's specific concerns.

    The Node Package Manager is a tool which ships with Node and assist with the searching, packaging, publishing and
    updating of node modules.

    Because every package module you add to your project becomes a dependency of your project, NPM is often considered a
    dependency manager, however it's much more.

    We saw an npm example when we install ExpressJS:

    ```
    $ npm install express
    ```

    If you look under the hood you’ll find that the NPM tool is in-fact a JavaScript file which runs at the command line
    using Node.

    In this example snap shot from my machine we see that npm is just a symlink to the npm-cli.js program.

    ```
    lrwxr-xr-x 1 root admin 38B Jul 21 23:45 npm -> ../lib/node_modules/npm/bin/npm-cli.js
    ```
  </aside>
</section>



<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- The NPM repository  --------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>The NPM repository</h3>
  <ul>
    <li>npmjs.org contains a massive repository of node packages</li>
    <li>Over 178,000 packages exist!</li>
    <li>There are no shortage of packages and likely dozens to fit your apps specific needs</li>
  </ul>
  <aside class="notes" data-markdown="">
    ---
    Visit npmjs.org and you'll find a massive repository of node packages. When I last visited the site, while writing
    this presentation, I found that on that day over 178,000 total packages existed with over 111 million downloads in
    the last day alone! npm has become the largest source package repository ever created. It has far surpassed other
    leading repositories such as RubyGems and CSPAN.

    For an interactive presentation see: https://unpm.nodesource.com/

    The npmjs.org site allows you to search for packages, so the problem isn't searching - it's finding which of many
    packages to use to address your app's concern. Let's just say that there is not shortage of packages!
  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Building and publishing an NPM package  ----------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Building and publishing an NPM package</h3>
  <ul>
    <li>You too can contribute Node modules!</li>
    <li>Let's see how</li>
  </ul>
  <aside class="notes" data-markdown="">
    ---
    Part of the reason that there are so many Node packages is because anyone can contribute a package. You won't find
    an acceptance committee such as those who police mobile app stores. In fact, you too can contribute node modules!
    We'll see how to do that next.

    About a year ago I contributed two open source packages to the NPM repository.

    Let me step through the process with you.

    * The I configured NPM for publishing

    $ npm set init.author.name "Carlos Justiniano"
    $ npm set init.author.email "carlos.justiniano@gmail.com"
    $ npm set init.author.url "http://cjus.me"
    $ npm adduser

    The last command wrote my credentials to the ~/.npmrc file, where it will be available to subsequent npm commands.

    * Next I created my project on github.
    * Then I update my projects package.json file to include information which NPM publish would need. Important fields
    include "name", "contributors", "repository", "keywords" and "license"
    * The npm publish command reads the package.json to determine how to configure and publish your project in the npm
    repository.
    * To publish we just use: npm publish

    For complete step by step tutorial see: https://quickleft.com/blog/creating-and-publishing-a-node-js-module/

  </aside>
</section>


<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- NVM - The Node Version Manager  ---------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>NVM - The Node Version Manager</h3>
  <ul>
    <li>NVM allows you to install and switch between different versions of Node</li>
    <li>This is useful for trying new features and testing existing code</li>
  </ul>
  <aside class="notes" data-markdown="">
    ---
    Node is updated periodically in response to enhancements and new features. It's a good idea to keep up with updates
    by trying your programs against newer version of Node. This can, however, become problematic if you only have one
    version of node installed on your machine at one time.

    To address this issue there is the Node Version Manager, a tool which allows you to install and switch between
    multiple versions of Node.

    Installing a new version of node is as simple as:

    $ nvm install 0.12.7

    And switching beween version is:

    $ nvm use 0.10.25

    to find out more about NVM visit: https://github.com/creationix/nvm

  </aside>
</section>


<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Uses of Node ----------------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Uses of Node</h3>
  <img style="border: 0; padding: 5px; width: 100%" src="images/UsesOfNode-01.png">
  <aside class="notes" data-markdown="">
    ---
    Node is being used to address many types of concerns.

    When people first learn about node they see it as a backend server technology, primarily used to build web facing
    applications.

  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Uses of Node - common -------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Uses of Node</h3>
  <img style="border: 0; padding: 5px; width: 100%" src="images/UsesOfNode-02.png">
  <aside class="notes" data-markdown="">
    ---
    Later they learn that Node is also used to power the build tools they use to package their web applications. Tools
    like Grunt and Gulp.

    Along the way we learn that node can be used to build command line tools. This is quickly becoming an alternative to
    shell / batch scripting.

    What many developers don’t realize is that Node is used to build desktop applications and power Robotics and the
    Internet of Things.

    You’ll find Node in use from tiny devices (see Node on Raspberry Pi) to large scale clusters running on cloud
    infrastructure.

    For JavaScript developers this is awesome. You get to take your JS and Node experience and apply it to an increasing
    field of opportunities. The same can’t be said for many other options.

  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Node and Robotics ------------------------------------------------------------------------------------------------>
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Node and Robotics</h3>
  <img style="border: 0; padding: 1px; width: 60%" src="images/U-87-Cyber-Combat-Unit.jpg">
  <p>Checkout CylonJS and NodeBots!</p>
  <aside class="notes" data-markdown="">
    ---
    Oh, and did I mention you can build robots using Node?

    Checkout CylonJS and NodeBots!
  </aside>
</section>


<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Node internals --------------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Node internals</h3>
  <img style="border: 0; padding: 5px; width: 100%" src="images/NodeJS-EventedIOAsyncIO_latest.png">
  <aside class="notes" data-markdown="">
    ---
    Node consist of two main parts. One part is concerned with handling requests in a single threaded loop. This is
    known as the event loop. This is also where the V8 JavaScript engine is used.

    Node takes I/O tasks and creates threads to handle them. This means that those threads are able to run efficiently
    on multi-processor and multi-core machines. In fact you can scale the single event loop process by running multiple
    version of node on a single machine. This is handled using Node clustering.

    You can think of Node’s Event loop as a staging area for I/O tasks.

    So why is this effective? Because a majority of time in web applications is spent waiting for file and network
    communication to take place. By not waiting for those requests to complete, Node can focus on handling more requests
    and running the rest of your code.

  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Node Add-ons: Extending Node, using C/C++ -------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Node Add-ons: Extending Node, using C++</h3>
  <ul>
    <li>Modules written as native C/C++ components call shareable objects</li>
    <li>Extends Node and JavaScript by allowing progams to call into the native module</li>
    <li>Let's see an actual example. Code available here: NodeJSProjects/node-addon</li>
  </ul>
  <aside class="notes" data-markdown="">
    ---
    Node can be extended using C/C++ native modules. There are a variety of reasons for wanting to do this, but a common
    one has to do we getting absolute performance. Another reason is to hook into lower level Node functionality which
    might not be accessible from JavaScript. At least one reason to avoid doing this is that addons have to be compiled
    for each platform they're expected to run on. So you lose the portability inherit in most JavaScript node
    applications.

    Node itself is written in the C++ programming language. As such, it can be extended using C and/or C++. Node add-ons
    are packaged as dynamically loadable modules which is common in the *nix camp and similar to DLLs on the Microsoft
    Windows platform. The basic idea is that a module can exists outside of the main program as a component that can be
    loaded at runtime. This is an important approach because otherwise you'd have to obtain the NodeJS source code and
    extend it prior to rebuilding your own custom version. This is of course a bad idea on so many levels. But hey, this
    is open source - so you could do that if you really wanted too.

    Ok, let’s see an example!

    To do this I’ll need to log onto my Linux box on Amazon.
  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Preparing our build environment -------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Preparing our build environment</h3>
  <!--@formatter:off-->
<pre><code contenteditable style="font-size: 18px; margin-top: 20px;">
  $ npm install nan@latest --save
  $ sudo npm install node-gyp -g

</code></pre>
<!--@formatter:on-->
  <aside class="notes" data-markdown="">
    ---
    For this demo we need to install NAN, which allows us to which makes it easier to work with C++, Node and the V8
    API. It also allows us to more easily target multiple versions of Node

    $ npm install nan@latest --save

    Next we need to make sure that Node-gyp is installed globally. Node-gyp is a Node.js native addon build tool.

    $ sudo npm install node-gyp -g

  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Building our project -------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Building our project</h3>
  <!--@formatter:off-->
<pre><code contenteditable style="font-size: 18px; margin-top: 20px;">
    $ node-gyp configure
    $ node-gyp build

</code></pre>
<!--@formatter:on-->

Then we use in Node as:

  <!--@formatter:off-->
<pre><code contenteditable style="font-size: 18px; margin-top: 20px;">
  var addon = require('./build/Release/hello.node');
  console.log(addon.hello());

</code></pre>
<!--@formatter:on-->

  <aside class="notes" data-markdown="">
    ---
    Each Node addon consist of at least three files:

    * binding.gyp - binding information for our source files
    * One or more C/C++ files which actually make the code of our addon
    * A package.json file which describes our project and its dependencies

    We use node-gyp to configure our project

    $ clear
    $ node-gyp configure

    Now we can actually build our project

    $ node-gyp build

    The output of the last two operations is the creation of a hello.node module in the ~/node-addon/build/Release
    folder. This file is actually a Dynamic Shared Object which usally end in a .so extension. Here, node-gyp names our
    addon with a .node extension because Node looks for such files when a module is required.

    We can now use the new node addon in our JS projects:

    var addon = require('./build/Release/hello.node');
    console.log(addon.hello());

    For more information about this demo checkout:
    https://github.com/nodejs/node-addon-examples/tree/master/1_hello_world
    ### Useful links for understanding and building Node add-ons

    So much of this is outside the scope of this talk, but if you're interested in learning more see these great
    articles:

    * https://nodejs.org/api/addons.html
    * https://www.npmjs.com/package/node-gyp
    * https://www.youtube.com/watch?v=q1ri36UI5GA

  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Microservices and Node ------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Microservices and Node</h3>
  <ul>
    <li>Micro Services is "An approach to developing a single application as a suite of small services". - Martin Fowler</li>
    <li>Node has emerged as an ideal way of building Micro Services. Coupled with a framework such as Express and the vastness that is NPM, Node-based microservices can be quickly built and tested.</li>
  </ul>
  <aside class="notes" data-markdown="">
    ---
    Micro Services is "An approach to developing a single application as a suite of small services". - Martin Fowler

    There a number of reason for doing this:

    * Bodies of code serve specific functionality, such as email, order processing or image processing.
    * Code is easier to maintain for each service.
    * Each service can be build using the technologies that given team feels comfortable with.
    * Large applications can scale based on the load of individual services.

    Node has emerged as an ideal way of building Micro Services. Coupled with a framework such as Express and the
    vastness that is NPM, Node-based microservices can be quickly built and tested.

    Good links on Microservices:
    * https://www.youtube.com/watch?v=2yko4TbC8cI
    * https://www.youtube.com/watch?v=wgdBVIX9ifA
    * https://www.youtube.com/watch?v=nMTaS07i3jk
    * https://www.youtube.com/watch?v=X0_d0ci8UcY
    * http://exponential.io/blog/nodeday-2014-you-only-need-100-lines-of-javascript/

    William Blankenship's talk next month on "Rapidly developing microservices using Node.JS and Docker" will cover this
    topic in greater depth.

  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Microservices and Node Links ------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Good links on Microservices:</h3>
  <ul>
  <li>https://www.youtube.com/watch?v=2yko4TbC8cI</li>
  <li>https://www.youtube.com/watch?v=wgdBVIX9ifA</li>
  <li>https://www.youtube.com/watch?v=nMTaS07i3jk</li>
  <li>https://www.youtube.com/watch?v=X0_d0ci8UcY</li>
  <li>http://exponential.io/blog/nodeday-2014-you-only-need-100-lines-of-javascript/</li>
  </ul>
  <aside class="notes" data-markdown="">
    ---
    Good links on Microservices:
    * https://www.youtube.com/watch?v=2yko4TbC8cI
    * https://www.youtube.com/watch?v=wgdBVIX9ifA
    * https://www.youtube.com/watch?v=nMTaS07i3jk
    * https://www.youtube.com/watch?v=X0_d0ci8UcY
    * http://exponential.io/blog/nodeday-2014-you-only-need-100-lines-of-javascript/

    William Blankenship's talk next month on "Rapidly developing microservices using Node.JS and Docker" will cover this
    topic in greater depth.

  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Microservices and Node Next Talk ------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="fade" data-transition-speed="medium">
  <h3>Don't miss next month's talk:</h3>
  <p>Rapidly developing microservices using Node.JS and Docker<br>by William Blankenship</p>
  <aside class="notes" data-markdown="">
    ---
    William Blankenship's talk next month on "Rapidly developing microservices using Node.JS and Docker" will cover this
    topic in greater depth.
  </aside>
</section>

<!-- ------------------------------------------------------------------------------------------------------------------>
<!-- Contact ---------------------------------------------------------------------------------------------------------->
<!-- ------------------------------------------------------------------------------------------------------------------>
<section data-transition="cube" data-transition-speed="slow">
  <h3>Contact</h3>
  <ul>
    <li>cjus on Twitter and Github</li>
    <li>Email: cjus34@gmail.com</li>
    <li>About: http://cjus.me</li>
  </ul>
</section>


</div>
</div>

<!-- reveal -->
<script src="lib/js/head.min.js"></script>
<script src="js/reveal.min.js"></script>
<script>
  // Full list of configuration options available here:
  // https://github.com/hakimel/reveal.js#configuration
  Reveal.initialize({
    controls: true,
    progress: true,
    history: true,
    center: true,

    theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
    transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/none/fade/none

    // Parallax scrolling
    //    parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
    //    parallaxBackgroundSize: '2100px 900px',

    leap: {
      //gestureDelay: 1000,
      //pointerTolerance: 40,
      naturalSwipe: true,    // Invert swipe gestures
      pointerOpacity: 0.25,      // Set pointer opacity to 0.5
      pointerColor: '#FFFFFF' // color pointer
    },

    // Optional libraries used to extend on reveal.js
    dependencies: [
      { src: 'lib/js/classList.js', condition: function() {
        return !document.body.classList;
      } },
      { src: 'plugin/markdown/marked.js', condition: function() {
        return !!document.querySelector('[data-markdown]');
      } },
      { src: 'plugin/markdown/markdown.js', condition: function() {
        return !!document.querySelector('[data-markdown]');
      } },
      { src: 'plugin/highlight/highlight.js', async: true, callback: function() {
        hljs.initHighlightingOnLoad();
      } },
      { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() {
        return !!document.body.classList;
      } },
      { src: 'plugin/notes/notes.js', async: true, condition: function() {
        return !!document.body.classList;
      } },
      //{ src: 'plugin/leap/leap-0.2.0.js', async: true }
    ]
  });

//  Reveal.addEventListener('slidechanged', function(event) {
//    // event.previousSlide, event.currentSlide, event.indexh, event.indexv
//    if (event.indexh === 1) {
//      canvasDemo01.start();
//    } else {
//      canvasDemo01.stop();
//    }
//    console.log(event.indexh);
//  });

  // Reveal.addEventListener('slidechanged', function(event) {
  //   var notes = event.currentSlide.querySelector(".notes");
  //   if (notes) {
  //     console.info(notes.innerHTML.replace(/\n\s+/g,'\n'));
  //   }
  // });
</script>
</body>
</html>

